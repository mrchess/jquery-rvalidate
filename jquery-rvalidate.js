// Generated by CoffeeScript 1.3.3

/*
jQuery rValidator Plugin 0.0.1
http://github.com/mrchess/jquery-rvalidation
Copyright (c) 2012 Justin Ho
This is free. Do whatever.
*/


(function() {
  var emailRegEx, error_defaults;

  emailRegEx = /^([a-zA-Z0-9])(([a-zA-Z0-9])*([\._\+-])*([a-zA-Z0-9]))*@(([a-zA-Z0-9\-])+(\.))+([a-zA-Z]{2,4})+$/;

  emailRegEx = new RegExp(emailRegEx);

  error_defaults = {
    invalid_email: "Not a valid e-mail address.",
    presence: "Field is required.",
    not_a_number: "Field is not a number.",
    not_greater_than: "Value is too small.",
    not_less_than: "Value is too large.",
    not_equal_to: "Not equal to.",
    too_short: "Value is too short.",
    too_long: "Value is too long.",
    wrong_length: "Value is wrong length.",
    not_confirmed: "Values do not match."
  };

  $.fn.rvalidate = function(config) {
    var confirmInput, confirmation, el, email, errors, form, length, numericality, o, presence, selector, val, valid, validations;
    if (config) {
      $(this).data('rvalidator', config);
      return true;
    } else {
      config = $(this).data('rvalidator');
      this.errors = [];
      form = $(this);
      for (selector in config) {
        validations = config[selector];
        el = form.find(selector);
        val = el.val();
        errors = [];
        presence = validations.presence;
        if (presence) {
          if (!val.length) {
            errors.push(presence.blank || error_defaults.presence);
          }
        }
        numericality = validations.numericality;
        if (numericality) {
          if (val.match(/\D/) || !val.length) {
            errors.push(numericality.not_a_number || error_defaults.not_a_number);
          } else {
            if (numericality.equal_to) {
              if (parseInt(val) !== numericality.equal_to) {
                errors.push(numericality.not_equal_to || error_defaults.not_equal_to);
              }
            }
            if (numericality.greater_than) {
              if (parseInt(val) <= numericality.greater_than) {
                errors.push(numericality.not_greater_than || error_defaults.not_greater_than);
              }
            }
            if (numericality.less_than) {
              if (parseInt(val) >= numericality.less_than) {
                errors.push(numericality.not_less_than || error_defaults.not_less_than);
              }
            }
          }
        }
        email = validations.email;
        if (email) {
          if (email.regex) {
            valid = new RegExp(email.regex).test(val);
          } else {
            valid = emailRegEx.test(val);
          }
          if (!valid) {
            errors.push(email.invalid_email || error_defaults.invalid_email);
          }
        }
        length = validations.length;
        if (length) {
          if (length.iz) {
            if (val.length !== length.iz) {
              errors.push(length.wrong_length || error_defaults.wrong_length);
            }
          }
          if (length.minimum) {
            if (val.length < length.minimum) {
              errors.push(length.too_short || error_defaults.too_short);
            }
          }
          if (length.maximum) {
            if (val.length > length.maximum) {
              errors.push(length.too_long || error_defaults.too_long);
            }
          }
        }
        confirmation = validations.confirmation;
        if (confirmation) {
          confirmInput = form.find(confirmation.confirms_with);
          if (confirmInput.length) {
            if (val !== confirmInput.val()) {
              errors.push(confirmation.not_confirmed || error_defaults.not_confirmed);
            }
          } else {
            throw "Missing input to confirm with.";
          }
        }
        if (errors.length) {
          o = {};
          o["" + selector] = errors;
          this.errors.push(o);
        }
      }
    }
    if (this.errors.length) {
      return this.errors;
    } else {
      return [];
    }
  };

}).call(this);
